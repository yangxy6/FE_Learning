# 位操作

位运算即是在位级别进行操作的技术，合适的位运算能够帮助我们得到更快地运算速度与更小的内存使用。

|       运算符       |  用法   |                                       描述                                        |
| :----------------: | :-----: | :-------------------------------------------------------------------------------: |
|   按位与（AND）    |  a & b  |   对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。   |
|    按位或（OR）    | a \| b  |  对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。  |
|  按位异或（XOR）   |  a ^ b  | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。 |
|   按位非（NOT）    |   ~a    |                    反转操作数的比特位，即 0 变成 1，1 变成 0。                    |
| 左移（Left shift） | a << b  |             将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。              |
|     有符号右移     | a >> b  |               将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。               |
|     无符号右移     | a >>> b |    将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。     |

- 测试第 k 位: s & (1 << k)
- 设置第 k 位: s |= (1 << k)
- 第 k 位置零: s &= ~(1 << k)
- 切换第 k 位值: s ^= ~(1 << k)
- 乘以 2n: s << n
- 除以 2n: s >> n
- 交集: s & t
- 并集: s | t
- 减法: s & ~t
- 交换 x = x ^ y ^ (y = x)
- 取出最小非 0 位（Extract lowest set bit）: s & (-s)
- 取出最小 0 位（Extract lowest unset bit）: ~s & (s + 1)
- 交换值: x ^= y; y ^= x; x ^= y;

## 异或

异或的结果就是两个数差异所在，点位中 1 代表差异位

1. 两数相加
   > 来源：Leetcode 第 190 题  
   > 思路：竖式加法，a&b 获取进位，a^b 无进位加法

```js
var getSum = function(a, b) {
  while (b !== 0) {
    // 直到b=0，没有需要进位的了
    let temp = (a & b) << 1; //a&b 获取进位，同时左移1位
    a = a ^ b; // a^b无进位加法
    b = temp;
  }
  return a;
};
```

2. 交换两个变量
   > 来源：
   > 思路：异或操作

```js
// 简单来说 a^b类似temp保留了两个数互异的点位，并赋值给a，再次a^b得到就是a原来的值
function swap(a, b) {
  a ^= b; //a中存放两数互异的点位
  b ^= a; // 取反 b 中不同于 a 的点位，也就是实现了 b = a
  a ^= b; // 取反 a 中不同于 b 的点位，也就是实现了 a = b
}
```

3. a 转换 b
   > 来源：
   > 思路：异或，两个数做异或的结果就是两个数差异所在，然后只需计算这个结果中有多少个 1 即可。

```js
function convertA2B(a, b) {
  let n = a ^ b; // n中存放ab两数互异点位，计算1的次数代表需要转化的位数
  let count = 0;
  while (n !== 0) {
    n = n & (n - 1); // n与n-1末位肯定是不同值，n&n-1可以消除一次1
    count++;
  }
  return count;
}
```

4. 只出现一次的数字
   > 来源：Leetcode 第 136 题  
   > 思路：
   >
   > - 异或运算和乘法一样，位置和运算顺序不影响最后结果：a^b^c = b^c^a
   > - 两个相同的数做异或运算结果为零：a^a = 0
   > - 任何数和零做异或结果还是这个数本身：a^0 = a

```js
var singleNumber = function(nums) {
  let ans;
  for (let i = 0; i < nums.length; i++) {
    ans ^= nums[i]; // 异或操作与顺序没有关系a^b^c与c^b^a一样，其中a^a=0两个相同值没有互异的点位
  }
  return ans;
};
```

5. 数字转换为十六进制数
   > 来源：Leetcode 第 405 题  
   > 思路：
   >
   > - -1 反码是 1111 1110 补码 1111 1111  
   >   补码是反码加 1  
   >   所以-1&15 是 15 也就是 f  
   >   15 是 ffff，整数&15=整数
   > - \>>> 4 无符号右移四位

```js
var toHex = function(num) {
  const hex = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
  if (num === 0) return '0';
  let arr = [];
  while (num !== 0 && arr.length < 8) {
    arr.push(hex[num & 15]);
    num = num >>> 4;
  }
  return arr.reverse().join('');
};
```
